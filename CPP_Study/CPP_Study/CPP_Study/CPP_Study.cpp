
#include <iostream>

// 0이 아닌 초기화 값이 있으면 .data 영역
int hp = 100;

char a;     // 1 바이트 (-128~127)
short b;    // 2 바이트 (-32768~32767)
int c;      // 4 바이트 (-21.4억~21.4억)
__int64 d;  // 8 바이트 (long long)

unsigned char aa;     // 1 바이트 (0~255)
unsigned short bb;    // 2 바이트 (0~65536)
unsigned int cc;      // 4 바이트 (0~42.9억)
unsigned __int64 dd;  // 8 바이트 (long long)

float e = 0.639f;       // 4 바이트
double ee = 123.4123;   // 8 바이트

// 부동소수점
// .(소수점) 을 유동적으로 움직여서 표현하는 방법

// 3.1415926535
// 3.1415926535 = 0.31415926535 * 10 = 314.15926535 * 10^-2
// 1) 정규화 = 0.31415926535 * 10
// 2) 31415926535 (유효숫자) 1 (지수)

// float 부호(1) 지수(8) 유효숫자(23) = 32비트 = 4 바이트
// double 부호(1) 지수(11) 유효숫자(52) = 64비트 = 8 바이트

// ex) -3.375 라는 값을 저장
// 1) 2진수 변환 = (3) + (0.375) = 0b11 + 0b0.011 = 0b11.011
// 0.375 = 0.5 * 0 + 0.25 * 1 + 0.125 * 1 = 0b0.011
// 2) 정규화 0b1.1011 * 2^1
// 1(부호) 1(지수) 1011(유효숫자)
// 단 지수는 unsigned byte라고 가정하고 숫자+127 만들어줌
// 예상 결과 : 0b 1 10000000 1011000'0000'0000'0000'0000

// 초기값이 0이거나, 초기값이 없는 변수라면 .bss 영역

int main()
{
    // 정수 오버플로우
    b = 32767;
    b = b + 2;
    std::cout << b << '\n';

    // 정수 언더플로우
    bb = 0;
    bb = bb - 2;
    std::cout << bb << '\n';

    std::cout << "Hello World!\n";
}
